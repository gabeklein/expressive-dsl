{"version":3,"file":"index.js","sources":["src/element.ts","src/syntax.ts","src/jsx.ts","src/index.ts"],"sourcesContent":["import { Attribute, ExplicitStyle, InnerStatement, NonComponent, Prop, SpreadItem, ElementInline } from '@expressive/babel-plugin-core';\nimport { Statement, Expression } from '@babel/types';\n\nexport type SequenceItem = Element | Prop | ExplicitStyle | SpreadItem;\nexport type Element = ElementInline | NonComponent<any>;\nexport type GenerateStatement = InnerStatement<any>;\n\nexport type Syntax = [ Expression, Statement[]?];\n\nexport class ArrayStack<Type = any, Insert = never>\n    extends Array<Type[] | Insert> {\n\n    top?: Type[] | Insert;\n\n    insert(x: Type){\n       if(Array.isArray(this.top))\n            this.top.push(x)\n        else {\n            this.top = [x]\n            super.push(this.top)\n        }\n    }\n\n    push(x: Insert): number {\n        this.top = x;\n        return super.push(x);\n    }\n}\n\nexport class AttributeStack<Type extends Attribute> \n    extends ArrayStack<Type, SpreadItem> {\n\n    static = [] as Type[];\n    doesReoccur?: true;\n\n    constructor(previous?: AttributeStack<Type>){\n        super();\n        if(previous)\n            previous.doesReoccur = true;\n    }\n\n    insert(item: Type | SpreadItem): boolean {\n        if(item instanceof SpreadItem){\n            this.top = item\n            this.push(item);\n            if(item.orderInsensitive)\n                return true;\n        }\n        else \n        if(item.value && this.length < 2 \n        || (<SpreadItem>this.top).orderInsensitive){\n            this.static.push(item);\n            return true;\n        }\n        else\n            super.insert(item);\n\n        return false;\n    }\n}\n","import t, { Expression, LVal, Statement, JSXElement, JSXFragment } from '@babel/types';\nimport { Content, Props } from 'jsx';\n\nexport interface BunchOf<T> {\n    [key: string]: T\n}\n\nexport function createElement(\n    tag: string,\n    props = [] as Props[],\n    children = [] as Content[]\n): JSXElement {\n    const type = t.jsxIdentifier(tag);\n    return (\n        t.jsxElement(\n            t.jsxOpeningElement(type, props),\n            t.jsxClosingElement(type),\n            children,\n            children.length > 0\n        )\n    )\n}\n\nexport function createFragment(\n    children = [] as Content[]\n): JSXFragment {\n    return (\n        t.jsxFragment(\n            t.jsxOpeningFragment(),\n            t.jsxClosingFragment(),\n            children\n        )\n    )\n}\n\nexport function IIFE(stats: Statement[]){\n    return t.callExpression(\n        t.arrowFunctionExpression([], \n            t.blockStatement(stats as any)\n        ), []\n    )\n}\n\nexport function object(obj: BunchOf<any>){\n    const properties = [];\n    for(const x in obj)\n        properties.push(\n            t.objectProperty(\n                t.identifier(x),\n                obj[x]\n            )\n        )\n    return t.objectExpression(properties);\n}\n\nexport function member(\n    object: Expression | \"this\", \n    ...path: (string | number)[] ){\n\n    if(object == \"this\") \n        object = t.thisExpression()\n\n    for(let member of path){\n        let select;\n        \n        if(typeof member == \"string\"){\n            select = /^[A-Za-z0-9$_]+$/.test(member)\n                ? t.identifier(member)\n                : t.stringLiteral(member);\n        }\n        else if(typeof member == \"number\")\n            select = t.numericLiteral(member);\n        \n\n        object = t.memberExpression(object, select, select!.type !== \"Identifier\")\n    }\n    \n    return object\n}\n\nexport function declare(\n    type: \"const\" | \"let\" | \"var\", \n    id: LVal, \n    init?: Expression ){\n\n    return (\n        t.variableDeclaration(type, [\n            t.variableDeclarator(id, init)\n        ])\n    )\n}\n\nexport function array(\n    children: Expression, \n    getFirst: boolean = false ){\n\n    const array = t.callExpression(\n        t.memberExpression(\n            t.arrayExpression([]),\n            t.identifier(\"concat\")\n        ),\n        [children]\n    )\n    return getFirst ? t.memberExpression(array, t.numericLiteral(0), true) : array;\n}\n\nexport function require(module: string){\n    return t.callExpression(\n        t.identifier(\"require\"), \n        [ t.stringLiteral(module) ]\n    )\n}\n\n// export function createElement(\n//     type: string | StringLiteral | Identifier, \n//     props: Expression = t.objectExpression([]), \n//     ...children: Expression[] ){\n\n//     if(Opts.output == \"JSX\")\n//         return jsx.createElement(type, props, ...children);\n\n//     if(typeof type == \"string\") \n//         type = t.stringLiteral(type);\n\n//     const CREATE_ELEMENT = Shared.stack.helpers.createElement;\n\n//     return t.callExpression(CREATE_ELEMENT, [type, props, ...children])\n// }\n\n// export function createFragment(\n//     elements: any[], \n//     props = [] as ObjectProperty[] ){\n\n//     if(Opts.output == \"JSX\")\n//         return jsx.createFragment(elements, props);\n\n//     let type = Shared.stack.helpers.Fragment;\n\n//     if(elements.length == 1)\n//         return this.applyProp(\n//             elements[0],\n//             props\n//         )\n\n//     return this.createElement(\n//         type, t.objectExpression([]), ...elements\n//     )\n// }\n\n// export function applyProp(element: any, props: any){\n//     if(Opts.output == \"JSX\"){\n//         props = props.map(convertObjectProps);\n//         element.openingElement.attributes.push(...props)\n//     }\n//     else {\n//         element.arguments[1].properties.push(...props)\n//     }\n//     return element;\n// }\n\n// export function element(){\n//     return {\n//         inlineType: \"child\",\n//         transform: (type: string) => ({\n//             product: this.createElement(type)\n//         })\n//     }\n// }","import { NodePath as Path } from '@babel/traverse';\nimport t, {\n    JSXAttribute,\n    JSXElement,\n    JSXExpressionContainer,\n    JSXFragment,\n    JSXSpreadAttribute,\n    JSXSpreadChild,\n    JSXText,\n    Expression,\n} from '@babel/types';\nimport {\n    AssembleElement,\n    DoExpressive,\n    Element,\n    ElementInline,\n    ExplicitStyle,\n    Prop,\n    SpreadItem,\n    ComponentIf,\n    ComponentFor,\n    ComponentConsequent,\n    StackFrame,\n} from '@expressive/babel-plugin-core';\nimport { AttributeStack } from 'element';\nimport { createElement, createFragment } from 'syntax';\n\nexport type Content = JSXElement | JSXFragment | JSXExpressionContainer | JSXText | JSXSpreadChild;\nexport type Props = JSXAttribute | JSXSpreadAttribute;\n\nclass SwitchJSX {\n\n    source: ComponentIf\n    context: StackFrame;\n\n    constructor(source: ComponentIf){\n        this.source = source;\n        this.context = source.parent.context;\n    };\n\n    apply(parent: ElementJSX){\n        parent.children.push(\n            t.jsxExpressionContainer(this.inline())\n        )\n    }\n\n    inline(){\n        const { children } = this.source;\n        if(children.length > 1)\n            return children.reduceRight(\n                this.inlineReduction.bind(this), \n                t.booleanLiteral(false)\n            );\n        else {\n            let { test, product } = this.extract(children[0]);\n            \n            let check: Expression = test!;\n\n            if(check.type == \"LogicalExpression\")\n                check = check.right;\n                \n            if(check.type != \"BooleanLiteral\" \n            && check.type != \"BinaryExpression\")\n                check = t.unaryExpression(\"!\", t.unaryExpression(\"!\", check))\n\n            return t.logicalExpression(\"&&\", check, product);\n        }\n    }\n\n    inlineReduction(alternate: Expression, current: ComponentConsequent){\n        const { test, product } = this.extract(current);\n        return test \n            ? t.conditionalExpression(test, product, alternate)\n            : product\n    }\n\n    extract(item: ComponentConsequent): { test?: Expression, product: Expression } {\n        const { test } = item;\n\n        const product = new ContainerJSX(item).toElement()\n\n        return {\n            test: test && test.node,\n            product\n        };\n    }\n}\n\nexport class ElementJSX<From extends ElementInline = ElementInline> \n    extends AssembleElement<From> {\n\n    children = [] as Content[];\n    props = [] as Props[];\n    style = new AttributeStack<ExplicitStyle>();\n    statements = [] as any[];\n\n    constructor(source: From){\n        super(source);\n        this.parse();\n    }\n\n    toElement(): Content {\n        const { props, children } = this;\n        const { tagName = \"div\" } = this.source;\n\n        return createElement(\n            tagName, props, children\n        );\n    }\n\n    Content(item: Element){\n        this.children.push(\n            item instanceof ElementInline ? \n                new ElementJSX(item).toElement() :\n            item.node.type == \"StringLiteral\" ? \n                t.jsxText(item.node.value) :\n                t.jsxExpressionContainer(item.node)\n        );\n    }\n\n    Switch(item: ComponentIf){\n        this.children.push(\n            t.jsxExpressionContainer(\n                new SwitchJSX(item).inline()\n            )\n        )\n    }\n\n    Iterate(item: ComponentFor){\n        this.children.push(\n            createElement(\"foo-bar-loop\")\n        )\n    }\n\n    Props(item: Prop | SpreadItem){\n        const { name, value } = item; \n        let attribute: Props;\n\n        if(item instanceof SpreadItem){\n            attribute = t.jsxSpreadAttribute(item.node);\n        }\n        else if(/^[a-zA-Z_][\\w-]+$/.test(name)){\n            attribute = t.jsxAttribute(\n                t.jsxIdentifier(name), \n                typeof value == \"string\"\n                    ? t.stringLiteral(value)\n                    : t.jsxExpressionContainer(item.syntax)\n            )\n        }\n        else \n            throw new Error(`Illegal characters in prop named ${name}`)\n\n        this.props.push(attribute);\n    }\n\n    Style(item: ExplicitStyle | SpreadItem){\n        // this.style.insert(item);\n    }\n\n    Statement(item: any){\n        \n    }\n}\n\nexport class ContainerJSX<T extends ElementInline>\n    extends ElementJSX<T> {\n\n    replace(path: Path<DoExpressive>){\n        path.replaceWith(\n            this.toElement()\n        )\n    }\n\n    toElement(): JSXElement | JSXFragment {\n        const { props, children } = this;\n        const tagName = this.source.tagName || \"div\";\n\n        if(props.length == 0){\n            const [ child, next ] = children;\n            if(!next && t.isJSXElement(child))\n                return child;\n            else\n                return createFragment(children)\n        }\n\n        return createElement(\n            tagName, \n            props, \n            children\n        );\n    }\n}","import { VisitNodeObject as Visit } from '@babel/traverse';\nimport Visitor, { DoExpressive, ComponentExpression } from '@expressive/babel-plugin-core';\nimport { ContainerJSX } from './jsx';\n\nexport default (options: any) => {\n    return {\n        inherits: Visitor,\n        visitor: {\n            DoExpression: <Visit<DoExpressive>>{\n                exit(path){\n                    const { meta } = path.node;\n                    if(meta instanceof ComponentExpression)\n                        new ContainerJSX(meta).replace(path);\n                }\n            }\n        }\n    }\n}"],"names":["SpreadItem","AssembleElement","ElementInline","Visitor","ComponentExpression"],"mappings":"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"}